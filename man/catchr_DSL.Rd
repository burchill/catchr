% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/help-docs.R
\name{catchr_DSL}
\alias{catchr_DSL}
\alias{language_of_catchr}
\alias{reserved_terms}
\alias{masking}
\alias{tomessage}
\alias{towarning}
\alias{toerror}
\alias{beep}
\alias{display}
\alias{muffle}
\alias{exit}
\alias{raise}
\title{The language of catchr}
\description{
\code{catchr} implements a small but helpful "domain-specific language" (DSL) to make building condition-handling functions simpler to read and type, somewhat like . Essentially, \code{catchr} reserves special 'terms' that mean something different than they do in the rest of R. When given as part of the input for a \code{catchr} plan, these terms will be substituted for special \code{catchr} functions used to handle conditions.

These special terms can be inputted as strings (e.g., \code{warning = list('collect', 'muffle')}) or as unquoted terms (e.g., \code{warning = c(collect, muffle)}); \code{catchr} internally converts the unquoted terms to strings regardless, but being able to input them unquoted saves keystrokes and can highlight their special meanings for code readability.
}
\section{Special reserved terms}{


The following are the special terms and what they do. Note that there are also some \link[=reserved_condition]{special condition names}, but those are different from the following.
\itemize{
\item \code{tomessage}, \code{towarning}, \code{toerror}: these terms will become functions that will convert captured conditions into a message, warning, or error, respectively, and raise them. The original classes of the condition will be lost.
\item \code{beep}: if the \link[beepr:beepr-package]{beepr} package is installed, this will play a sound via \code{\link[beepr:beepr]{beepr::beep}}.
\item \code{display}: the purpose of this term is to immediately display information about the captured condition on the screen without raising additional conditions (as would be done with \code{tomessage}). Currently, this term just calls \code{\link[utils]{str}} on the condition, \strong{but this will probably change in later versions.}
\item \code{muffle}: this term will be substituted for a function that 'muffles' (i.e., 'suppresses', 'catches', 'hides'---whatever you want to call it) the captured condition, preventing it from being raised to higher levels or subsequent plans. Anything in a plan \emph{after} \code{muffle} will be ignored, so put it last. \cr
The function \code{muffle} is built on, \code{\link{first_muffle_restart}}, searches for the first available \link[base:conditions]{restart} with \code{"muffle"} in its name (the two typical ones are \code{"muffleMessage"} and \code{"muffleWarning"}) and calls \code{invokeRestart} with it. If the captured condition is an error, which can't be muffled, it will exit the evaluation and give \code{NULL} for the returned value of the evaluated expression.
\item \code{exit}: when encountered, this will exit the evaluation of the expression immediately and by default muffle the captured condition (use \code{raise} to ensure this doesn't happen). Any instructions after \code{exit} in the input will be ignored, so put it last. To keep \code{catchr}'s behavior similar to how conditions are handled elsewhere, whatever the previous function in the plan returned will be returned as the value of the evaluated expression, so if you want to make sure you knew the evaluated expression did not finish, make sure the previous function returns \code{NULL} (e.g., use \code{function(cond) NULL}).
\item \code{collect}: this term will store the captured conditions and append them to the output of the evaluated expression. See the \link[=collecting-conditions]{Collecting conditions} help topic for a full explanation.
\item \code{raise}: this term will raise the captured condition "as is". The only \emph{real} use for this term is when you want to use \code{exit} to stop the evaluation, but to still raise the condition past that as well (in which case, put \code{raise} in the plan before \code{exit}). The behavior of this raising might be slightly unpredictable for very odd edge-cases (e.g., if a condition were both a warning \emph{and} an error).
}
}

\section{Masking}{


\code{catchr} will turn unquoted special terms into functions, but what happens if these unquoted terms are identical to variables previously declared?

If \code{muffle} is the name of a user-defined function, e.g., \code{muffle <- function(x) print("Wooo!")}, in normal R we would expect \code{warning = muffle} to make \code{function(x) print("Wooo!")} the warning handler.

\emph{However}, \code{catchr}'s DSL "masks" any symbol that matches one of its reserved terms, and when it evaluates these symbols, they are converted into strings. For the most part, \code{catchr} will warn you when this happens.

\strong{Importantly}, \code{catchr} does \emph{not} mask reserved terms when:
\itemize{
\item the reserved names are being used as calls, e.g., \code{warning = collect(foo)}. In these cases, it will attempt to use a previously defined function \code{collect} on \code{foo}, and will attempt to use whatever that evaluates to. The reserved terms are all strings/unquoted bare symbols, so it is never a problem anyway.
\item when the input specifically references a namespace/package, such as \code{warning = dplyr::collect}. When the symbol of a special terms is preceded by \code{::} or \code{:::}, it will be seen as the function of that package, and not as the special term \code{collect}.
\item the reserved terms are used inside a function definition. For example, if the user had defined \code{muffle <- function(x) print("not special")}, and \code{fn <- function(x) muffle}, using the argument \code{warning = fn()} would not use the special term of \code{muffle}.
}
}

