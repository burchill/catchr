---
output: 
  github_document:
    pandoc_args: "--atx-headers"
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(catchr)
library(purrr)
library(future)
```

[![Travis-CI Build Status](https://travis-ci.com/burchill/catchr.svg?branch=master)](https://travis-ci.com/burchill/catchr)

```{r, echo=FALSE}
# [![CRAN status](https://www.r-pkg.org/badges/version/furrr)](https://cran.r-project.org/package=furrr)
# [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/DavisVaughan/furrr?branch=master&svg=true)](https://ci.appveyor.com/project/DavisVaughan/furrr)

```

# catchr: The easier way of catching errors, warnings, and conditions

## "Exceptions?" "Conditions?" Making conditions work for _you_ in R

Compared to many other programming languages, the way R handles 'conditions'---errors, warnings, messages, and most things referred to as 'exceptions' in other languages---is pretty unintuitive, and can often be troublesome to users coming from different backgrounds. For example, on the surface the way exceptions are caught in Python seems so simple compared to R---_what even **is** a "restart"? What are those things people are referring to as "handlers" anyway?_

The purpose of `catchr` is to provide flexible, useful tools for handling R conditions with less hassle and head-scratching.  One of the most important goals of this package is to maintain a continuous learning curve that so new users jump straight in, but more advanced users can find the depth and complexity they need to take advantage of R's powerful condition-handling abilities.

To lower the barrier of entry, keep code clean and readable, and reduce the amount of typing required, `catchr` uses a very simple domain-specific language that simplifies things on the front-end. `catchr` focuses on letting users generate their own "catching" functions where they can specify behavior via conceptual "plans", removing unnecessary complexities---like the distinction between "calling" vs. "exiting" handlers---and adding many very useful features, like the ability to "collect" the conditions raised from a call.

## Installation

You can install the released version of catchr from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("catchr")
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("burchill/catchr")
```

## Introduction

In R, "warnings" (which generally indicate something _might_ be going wrong), "errors" (which indicate something _definitely_ has gone wrong), and "messages" (which generally just indicate neutral information) are all subclasses of "conditions", and they make up a vast majoirty of the conditions you will ever encounter if you're not a developer.  

When a condition is "raised", the code essentially stops, and the condition floats up through the code until something "catches" it or not. If nothing catches it and deals with it, warnings, messages, and errors will print a message out on your screen. Then, unless the condition was an error, the code picks up where it left off.  

Phrased as such, conditions may seem like no big deal. And for many basic uses of R, maybe they're not---if you're just tidying up some data and making a plot out of it, you can react to warnings and errors as they come, with little cost.  But for more involved R projects, being able to deal with conditions programmatically becomes _indispensable_.

## A basic example

An introduction to using `catchr` can be found in the vignettes (`vignette("welcome-to-catchr","catchr")` if you've installed it). Here, let's just cover some cases to demonstrate what the code looks like, and some of the advantages it offers.

Let's look at a _very_ simple case first. As you may know, trying to take the log of a negative number raises a warning and returns a `NaN`. There are times where it would be important _not_ to encounter a `NaN`, and maybe you want the code to stop whenever a warning of any kind is raised.

```{r example}
library(catchr)

fake_model <- function(x) {
  y <- log(x)
  c(y, x+1)
}

# Works fine
fine_results <- catch_expr(fake_model(5), warning = toerror)
```

But when a `NaN` is made and a warning is raised, `catchr` converts the warning into an error and the code stops:

```{r eval=FALSE}
# Stops the code
bad_results <- catch_expr(fake_model(-7), warning = toerror)
```

But let's say you want to be alerted about this issue as soon as possible and you're working on something else in a different window while the code runs. You can have `catchr` play a beeping sound whenever this event happens with a simple addition:

```{r eval=FALSE}
# Stops the code and make a beeping sound
bad_results <- catch_expr(fake_model(-7), warning = c(beep, toerror))
```

`catchr` is designed so that making "plans" for how a condition is handled simple, extendable, and flexible. In the example above, we made a "plan" for conditions of the class "warning" so that when one is raise, first a beep is played and then it is converted to an error.

## `catchr` "plans"

In `catchr` has a 

Special terms | Function
--------------------- | -------------------------------------------------------
`tomessage`, `towarning`, `toerror` | convert conditions to other types of conditions
`beep` | play a short sound
`display` | displays the contents of the condition on-screen
`collect` | collects the condition and saves it to a list that will be returned at the end
`muffle` | "muffles",^[i.e., "suppresses", "catches", "hides"---whatever you want to call it] a condition so it doesn't keep going up, and restarts the code
`exit` | immediately stops the code and muffles the condition
`raise` | raises conditions past `exit`






```{r}


condition_thrower <- function() {
  warning("1")
  message("A")
  warning("2")
  rlang::signal(message="X", "A custom condition")
  stop("collaborate and listen")
}

res <- collect_conditions(
  {
    warning("warning 1")
    message("message 1", appendLF = F)
    warning("warning 2")
    signal_custom_condition("Custom condition!")
    "test value"
  },
  catchErrors = FALSE)
print(res)

# `col_cond` is the shorter alias of `collect_conditions`
col_cond(stop("Error!"), asStrings = T)$errors
```

We can then decide to raise and signal all the conditions we've captured, while making the output pretty and easy to read. In the actual console (as opposed to this Markdown file), you won't get the `Warning in doWithOneRestart(return(expr), restart)` text.

```{r,echo=FALSE}
# Have to do this to get the output to work right
real_raise_conditions <- raise_conditions
raise_conditions <- function(x, ...)  {
  capture.output(real_raise_conditions(x, ...), type="message", file=stdout())
  x
}

```

```{r}
raise_conditions(res)
```


## Use in `future`

`catchr` can be incredibly useful when trying to diagnose code run in parallel or on remote machines, like it is with `future`. Although `future` has come a long way in terms of how easy it is to debug (because [Henrik Bengtsson](https://github.com/HenrikBengtsson) is both a saint and a genius), but capturing and returning every condition that was raised is much easier with `catchr`. 

```{r future}
library(future)
plan(multiprocess) # you could use `remote` or whatever you need
future_res %<-% {
  col_cond(
    {
      warning("You'll get an error because of X")
      stop("Why did you get this error?")
      "terminates before this value"
    }
  )
}

raise_conditions(future_res, raise_errors = FALSE)
```


## Use in `purrr`

`catchr` is also great with `purrr`, for example, if you're running a bunch of models via `map`.[^1] If you want to capture which models had which problems (and then print them all pretty), it's trivial to do so.

```{r getting l, echo=FALSE}
l <- list(
  collect_conditions({warning("Bad eigenvalues, bro"); warning("Convergence failure!"); "model-1"}),
  collect_conditions({message("Dropping contrasts"); warning("Were those contrasts important?"); "model-2"}),
  collect_conditions({message("I'm tired of this data!"); stop("lmers became sentient!"); "model-3"},
                     catchErrors=TRUE)
)
```

```{r purrr}
library(purrr)
# Let's assume `l` came from `col_cond`-ing a bunch of models
#   e.g., `map(datasets, ~col_cond(model_func(.)))`
results <- l %>% imap(function(e, i)
  raise_conditions(e, raise_errors=FALSE,
                   added_text=paste0(" in l[",i,"]:"))) %>%
  map(~evaluate_results(., raise_errors = FALSE))

print(results)
```


## Found a bug or have a suggestion?

Please open an issue and I'll try to get to it!


[^1]: I've found it's even *more* useful when you combine `purrr` and `future` via [`furrr`](https://github.com/DavisVaughan/furrr) (e.g., to run models in parallel). Shout-out to Davis Vaughan for his lovely code!
